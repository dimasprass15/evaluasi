<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Belajar Kaligrafi</title>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 800px;
            width: 100%;
        }

        .letter-display {
            background: white;
            color: #333;
            padding: 30px;
            border-radius: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            min-width: 200px;
        }

        .evaluation-mode {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            border: 3px solid #ff6b9d;
        }

        .word-display {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }

        .word-meaning {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 10px;
        }

        .evaluation-instruction {
            font-size: 1rem;
            color: #888;
            font-style: italic;
        }

        .current-letter {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }

        .letter-name {
            font-size: 1.5rem;
            color: #666;
            margin-bottom: 5px;
        }

        .letter-position {
            font-size: 1rem;
            color: #888;
            font-style: italic;
        }

        .canvas-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            margin: 20px 0;
        }

        #drawingCanvas {
            border: 3px dashed #ddd;
            border-radius: 15px;
            cursor: crosshair;
            touch-action: none;
            background-image: 
                linear-gradient(to right, #f0f0f0 1px, transparent 1px),
                linear-gradient(to bottom, #f0f0f0 1px, transparent 1px),
                linear-gradient(to bottom, #e0e0e0 1px, transparent 1px);
            background-size: 20px 20px, 20px 20px, 100% 50px;
            background-position: 0 0, 0 0, 0 25px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #a8e6cf, #7fcdcd);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feedback {
            padding: 15px 25px;
            border-radius: 15px;
            margin: 15px 0;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .feedback.show {
            opacity: 1;
        }

        .feedback.success {
            background: rgba(168, 230, 207, 0.9);
            color: #27ae60;
        }

        .feedback.encourage {
            background: rgba(255, 193, 7, 0.9);
            color: #f39c12;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #feca57; }
            100% { transform: scale(1); }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        .celebration-sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #ffd700, #ffed4e);
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .current-letter {
                font-size: 3rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">‚ú® Game Belajar Kaligrafi</div>
        <div class="subtitle">Belajar menulis huruf Arab dengan menyenangkan</div>
    </div>

    <div class="game-container">
        <div class="score">Skor: <span id="score">0</span></div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="letter-display">
            <div class="current-letter" id="currentLetter">ÿß</div>
            <div class="letter-name" id="letterName">Alif</div>
            <div class="letter-position" id="letterPosition">Bentuk Tunggal</div>
        </div>

        <div class="canvas-container">
            <canvas id="drawingCanvas" width="400" height="300"></canvas>
        </div>

        <div class="feedback" id="feedback"></div>

        <div class="controls">
            <button class="btn btn-primary" onclick="clearCanvas()">üóëÔ∏è Hapus</button>
            <button class="btn btn-secondary" onclick="nextLetter()">‚û°Ô∏è Huruf Berikutnya</button>
            <button class="btn btn-success" onclick="checkDrawing()">‚úÖ Periksa Tulisan</button>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="resetGameProgress()" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">üîÑ Reset Game</button>
        </div>
    </div>

    <script>
        // Data huruf Hijaiyah dengan berbagai bentuknya
        const hijaiyahLetters = [
            { letter: 'ÿß', name: 'Alif', forms: ['ÿß', 'ÿß', 'ŸÄÿß', 'ŸÄÿß'] },
            { letter: 'ÿ®', name: 'Ba', forms: ['ÿ®', 'ÿ®ŸÄ', 'ŸÄÿ®ŸÄ', 'ŸÄÿ®'] },
            { letter: 'ÿ™', name: 'Ta', forms: ['ÿ™', 'ÿ™ŸÄ', 'ŸÄÿ™ŸÄ', 'ŸÄÿ™'] },
            { letter: 'ÿ´', name: 'Tsa', forms: ['ÿ´', 'ÿ´ŸÄ', 'ŸÄÿ´ŸÄ', 'ŸÄÿ´'] },
            { letter: 'ÿ¨', name: 'Jim', forms: ['ÿ¨', 'ÿ¨ŸÄ', 'ŸÄÿ¨ŸÄ', 'ŸÄÿ¨'] },
            { letter: 'ÿ≠', name: 'Ha', forms: ['ÿ≠', 'ÿ≠ŸÄ', 'ŸÄÿ≠ŸÄ', 'ŸÄÿ≠'] },
            { letter: 'ÿÆ', name: 'Kha', forms: ['ÿÆ', 'ÿÆŸÄ', 'ŸÄÿÆŸÄ', 'ŸÄÿÆ'] },
            { letter: 'ÿØ', name: 'Dal', forms: ['ÿØ', 'ÿØ', 'ŸÄÿØ', 'ŸÄÿØ'] },
            { letter: 'ÿ∞', name: 'Dzal', forms: ['ÿ∞', 'ÿ∞', 'ŸÄÿ∞', 'ŸÄÿ∞'] },
            { letter: 'ÿ±', name: 'Ra', forms: ['ÿ±', 'ÿ±', 'ŸÄÿ±', 'ŸÄÿ±'] },
            { letter: 'ÿ≤', name: 'Zai', forms: ['ÿ≤', 'ÿ≤', 'ŸÄÿ≤', 'ŸÄÿ≤'] },
            { letter: 'ÿ≥', name: 'Sin', forms: ['ÿ≥', 'ÿ≥ŸÄ', 'ŸÄÿ≥ŸÄ', 'ŸÄÿ≥'] },
            { letter: 'ÿ¥', name: 'Syin', forms: ['ÿ¥', 'ÿ¥ŸÄ', 'ŸÄÿ¥ŸÄ', 'ŸÄÿ¥'] },
            { letter: 'ÿµ', name: 'Shad', forms: ['ÿµ', 'ÿµŸÄ', 'ŸÄÿµŸÄ', 'ŸÄÿµ'] },
            { letter: 'ÿ∂', name: 'Dhad', forms: ['ÿ∂', 'ÿ∂ŸÄ', 'ŸÄÿ∂ŸÄ', 'ŸÄÿ∂'] },
            { letter: 'ÿ∑', name: 'Tha', forms: ['ÿ∑', 'ÿ∑ŸÄ', 'ŸÄÿ∑ŸÄ', 'ŸÄÿ∑'] },
            { letter: 'ÿ∏', name: 'Zha', forms: ['ÿ∏', 'ÿ∏ŸÄ', 'ŸÄÿ∏ŸÄ', 'ŸÄÿ∏'] },
            { letter: 'ÿπ', name: 'Ain', forms: ['ÿπ', 'ÿπŸÄ', 'ŸÄÿπŸÄ', 'ŸÄÿπ'] },
            { letter: 'ÿ∫', name: 'Ghain', forms: ['ÿ∫', 'ÿ∫ŸÄ', 'ŸÄÿ∫ŸÄ', 'ŸÄÿ∫'] },
            { letter: 'ŸÅ', name: 'Fa', forms: ['ŸÅ', 'ŸÅŸÄ', 'ŸÄŸÅŸÄ', 'ŸÄŸÅ'] },
            { letter: 'ŸÇ', name: 'Qaf', forms: ['ŸÇ', 'ŸÇŸÄ', 'ŸÄŸÇŸÄ', 'ŸÄŸÇ'] },
            { letter: 'ŸÉ', name: 'Kaf', forms: ['ŸÉ', 'ŸÉŸÄ', 'ŸÄŸÉŸÄ', 'ŸÄŸÉ'] },
            { letter: 'ŸÑ', name: 'Lam', forms: ['ŸÑ', 'ŸÑŸÄ', 'ŸÄŸÑŸÄ', 'ŸÄŸÑ'] },
            { letter: 'ŸÖ', name: 'Mim', forms: ['ŸÖ', 'ŸÖŸÄ', 'ŸÄŸÖŸÄ', 'ŸÄŸÖ'] },
            { letter: 'ŸÜ', name: 'Nun', forms: ['ŸÜ', 'ŸÜŸÄ', 'ŸÄŸÜŸÄ', 'ŸÄŸÜ'] },
            { letter: 'Ÿá', name: 'Ha', forms: ['Ÿá', 'ŸáŸÄ', 'ŸÄŸáŸÄ', 'ŸÄŸá'] },
            { letter: 'Ÿà', name: 'Waw', forms: ['Ÿà', 'Ÿà', 'ŸÄŸà', 'ŸÄŸà'] },
            { letter: 'Ÿä', name: 'Ya', forms: ['Ÿä', 'ŸäŸÄ', 'ŸÄŸäŸÄ', 'ŸÄŸä'] }
        ];

        const positions = ['Tunggal', 'Awal', 'Tengah', 'Akhir'];
        
        // Data kata untuk evaluasi sambung huruf
        const evaluationWordSets = [
            // Set 1: Kata sederhana dengan huruf awal
            [
                { word: 'ÿ®Ÿéÿß', meaning: 'Ba', letters: ['ÿ®', 'ÿß'] },
                { word: 'ÿ™Ÿéÿß', meaning: 'Ta', letters: ['ÿ™', 'ÿß'] },
                { word: 'ÿ´Ÿéÿß', meaning: 'Tsa', letters: ['ÿ´', 'ÿß'] }
            ],
            // Set 2: Kata dengan 3 huruf
            [
                { word: 'ÿ¨ŸéŸÖŸéŸÑ', meaning: 'Unta', letters: ['ÿ¨', 'ŸÖ', 'ŸÑ'] },
                { word: 'ÿ≠Ÿéÿ®ŸéŸÑ', meaning: 'Tali', letters: ['ÿ≠', 'ÿ®', 'ŸÑ'] },
                { word: 'ÿÆŸéÿ®Ÿéÿ±', meaning: 'Berita', letters: ['ÿÆ', 'ÿ®', 'ÿ±'] }
            ],
            // Set 3: Kata dengan huruf yang tidak sambung
            [
                { word: 'ÿØŸéÿßÿ±', meaning: 'Rumah', letters: ['ÿØ', 'ÿß', 'ÿ±'] },
                { word: 'ÿ∞Ÿéÿ±Ÿéÿ©', meaning: 'Atom', letters: ['ÿ∞', 'ÿ±', 'ÿ©'] },
                { word: 'ÿ±Ÿéÿ£ÿ≥', meaning: 'Kepala', letters: ['ÿ±', 'ÿ£', 'ÿ≥'] }
            ],
            // Set 4: Kata dengan huruf sambung
            [
                { word: 'ÿ≥ŸéŸÖŸéŸÉ', meaning: 'Ikan', letters: ['ÿ≥', 'ŸÖ', 'ŸÉ'] },
                { word: 'ÿ¥ŸéŸÖÿ≥', meaning: 'Matahari', letters: ['ÿ¥', 'ŸÖ', 'ÿ≥'] },
                { word: 'ÿµŸéÿ®Ÿéÿ≠', meaning: 'Pagi', letters: ['ÿµ', 'ÿ®', 'ÿ≠'] }
            ]
        ];
        
        let currentLetterIndex = 0;
        let currentFormIndex = 0;
        let score = 0;
        let hasDrawn = false;
        let isEvaluationMode = false;
        let evaluationWords = [];
        let currentEvaluationIndex = 0;

        // Local Storage functions
        function saveGameProgress() {
            const gameData = {
                currentLetterIndex: currentLetterIndex,
                currentFormIndex: currentFormIndex,
                score: score,
                isEvaluationMode: isEvaluationMode,
                currentEvaluationIndex: currentEvaluationIndex,
                lastSaved: new Date().toISOString()
            };
            
            localStorage.setItem('hijaiyahGameProgress', JSON.stringify(gameData));
            console.log('Progress tersimpan:', gameData);
        }

        function loadGameProgress() {
            try {
                const savedData = localStorage.getItem('hijaiyahGameProgress');
                if (savedData) {
                    const gameData = JSON.parse(savedData);
                    
                    currentLetterIndex = gameData.currentLetterIndex || 0;
                    currentFormIndex = gameData.currentFormIndex || 0;
                    score = gameData.score || 0;
                    isEvaluationMode = gameData.isEvaluationMode || false;
                    currentEvaluationIndex = gameData.currentEvaluationIndex || 0;
                    
                    // Update display dengan data yang dimuat
                    document.getElementById('score').textContent = score;
                    
                    // Jika dalam mode evaluasi, setup evaluasi
                    if (isEvaluationMode) {
                        const setIndex = Math.min(Math.floor(currentLetterIndex / 3) - 1, evaluationWordSets.length - 1);
                        evaluationWords = evaluationWordSets[setIndex];
                    }
                    
                    console.log('Progress dimuat:', gameData);
                    showFeedback('üì± Progress terakhir berhasil dimuat!', 'success');
                    setTimeout(() => hideFeedback(), 3000);
                }
            } catch (error) {
                console.log('Tidak ada progress tersimpan atau error:', error);
            }
        }

        function resetGameProgress() {
            localStorage.removeItem('hijaiyahGameProgress');
            currentLetterIndex = 0;
            currentFormIndex = 0;
            score = 0;
            isEvaluationMode = false;
            currentEvaluationIndex = 0;
            document.getElementById('score').textContent = score;
            updateDisplay();
            clearCanvas();
            showFeedback('üîÑ Game direset ke awal!', 'success');
        }

        // Canvas setup
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let points = [];
        let smoothingFactor = 0.4;
        let minDistance = 2;
        let strokeHistory = [];
        let currentStroke = [];

        // Set canvas size responsively
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 40);
            canvas.width = maxWidth;
            canvas.height = Math.max(250, maxWidth * 0.75);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#333';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.globalCompositeOperation = 'source-over';
        }

        // Advanced smoothing functions
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function getAveragePoint(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }

        function smoothPath(points) {
            if (points.length < 3) return points;
            
            const smoothed = [];
            smoothed.push(points[0]);
            
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];
                
                // Apply weighted smoothing
                const smoothedPoint = {
                    x: prev.x * 0.25 + curr.x * 0.5 + next.x * 0.25,
                    y: prev.y * 0.25 + curr.y * 0.5 + next.y * 0.25
                };
                
                smoothed.push(smoothedPoint);
            }
            
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        // Drawing functions with balanced smoothing
        function startDrawing(e) {
            isDrawing = true;
            hasDrawn = true;
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            lastX = clientX - rect.left;
            lastY = clientY - rect.top;
            points = [{x: lastX, y: lastY, time: Date.now()}];
            currentStroke = [{x: lastX, y: lastY}];
        }

        function draw(e) {
            if (!isDrawing) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const currentX = clientX - rect.left;
            const currentY = clientY - rect.top;
            const currentPoint = {x: currentX, y: currentY, time: Date.now()};
            
            // Only add point if it's far enough from the last point
            const lastPoint = points[points.length - 1];
            const distance = getDistance(lastPoint, currentPoint);
            
            if (distance < minDistance) return;
            
            points.push(currentPoint);
            currentStroke.push(currentPoint);
            
            // Draw connected smooth line in real-time
            if (points.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                
                if (points.length >= 3) {
                    // Use quadratic curve for smoothing but keep it connected
                    const prevPoint = points[points.length - 3];
                    const midPoint = points[points.length - 2];
                    const currPoint = points[points.length - 1];
                    
                    // Create smooth control point
                    const controlX = midPoint.x + (currPoint.x - prevPoint.x) * smoothingFactor * 0.5;
                    const controlY = midPoint.y + (currPoint.y - prevPoint.y) * smoothingFactor * 0.5;
                    
                    ctx.quadraticCurveTo(controlX, controlY, currentX, currentY);
                } else {
                    // Simple line for first segment
                    ctx.lineTo(currentX, currentY);
                }
                
                ctx.stroke();
            }
            
            // Keep reasonable number of points
            if (points.length > 5) {
                points.shift();
            }
            
            lastX = currentX;
            lastY = currentY;
        }

        function drawSmoothCurve(points) {
            if (points.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length - 2; i++) {
                const currentPoint = points[i];
                const nextPoint = points[i + 1];
                
                // Create control points for smooth Bezier curve
                const controlPoint = getAveragePoint(currentPoint, nextPoint);
                
                ctx.quadraticCurveTo(
                    currentPoint.x,
                    currentPoint.y,
                    controlPoint.x,
                    controlPoint.y
                );
            }
            
            // Draw the last segment
            if (points.length > 2) {
                const secondLast = points[points.length - 2];
                const last = points[points.length - 1];
                ctx.quadraticCurveTo(
                    secondLast.x,
                    secondLast.y,
                    last.x,
                    last.y
                );
            }
            
            ctx.stroke();
        }

        function stopDrawing() {
            if (isDrawing && currentStroke.length > 1) {
                // Save current stroke to history
                strokeHistory.push([...currentStroke]);
            }
            
            isDrawing = false;
            points = [];
            currentStroke = [];
        }

        function drawCompleteStroke(strokePoints) {
            if (strokePoints.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(strokePoints[0].x, strokePoints[0].y);
            
            if (strokePoints.length === 2) {
                ctx.lineTo(strokePoints[1].x, strokePoints[1].y);
            } else {
                for (let i = 1; i < strokePoints.length - 1; i++) {
                    const currentPoint = strokePoints[i];
                    const nextPoint = strokePoints[i + 1];
                    const controlPoint = getAveragePoint(currentPoint, nextPoint);
                    
                    ctx.quadraticCurveTo(
                        currentPoint.x,
                        currentPoint.y,
                        controlPoint.x,
                        controlPoint.y
                    );
                }
                
                // Final point
                const lastPoint = strokePoints[strokePoints.length - 1];
                ctx.lineTo(lastPoint.x, lastPoint.y);
            }
            
            ctx.stroke();
        }

        // Event listeners for both mouse and touch
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokeHistory = [];
            points = [];
            currentStroke = [];
            drawGuideLines();
            hasDrawn = false;
            hideFeedback();
        }

        function drawGuideLines() {
            ctx.save();
            ctx.strokeStyle = '#e8e8e8';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // Draw horizontal guide lines
            const centerY = canvas.height / 2;
            const quarterY = canvas.height / 4;
            const threeQuarterY = (canvas.height * 3) / 4;
            
            ctx.beginPath();
            ctx.moveTo(0, quarterY);
            ctx.lineTo(canvas.width, quarterY);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(0, threeQuarterY);
            ctx.lineTo(canvas.width, threeQuarterY);
            ctx.stroke();
            
            ctx.restore();
        }

        function updateDisplay() {
            const letterDisplay = document.querySelector('.letter-display');
            
            if (isEvaluationMode) {
                letterDisplay.classList.add('evaluation-mode');
                const currentWord = evaluationWords[currentEvaluationIndex];
                
                document.getElementById('currentLetter').textContent = currentWord.word;
                document.getElementById('letterName').textContent = currentWord.meaning;
                document.getElementById('letterPosition').textContent = 'Tulis kata ini dengan menyambungkan huruf-hurufnya';
            } else {
                letterDisplay.classList.remove('evaluation-mode');
                const currentLetter = hijaiyahLetters[currentLetterIndex];
                const currentForm = currentLetter.forms[currentFormIndex];
                
                document.getElementById('currentLetter').textContent = currentForm;
                document.getElementById('letterName').textContent = currentLetter.name;
                document.getElementById('letterPosition').textContent = `Bentuk ${positions[currentFormIndex]}`;
            }
            
            // Update progress
            const totalForms = hijaiyahLetters.length * 4;
            const currentProgress = (currentLetterIndex * 4 + currentFormIndex + 1);
            const progressPercent = (currentProgress / totalForms) * 100;
            document.getElementById('progressFill').style.width = progressPercent + '%';
        }

        function nextLetter() {
            if (isEvaluationMode) {
                currentEvaluationIndex++;
                if (currentEvaluationIndex >= evaluationWords.length) {
                    // Selesai evaluasi, kembali ke mode normal
                    isEvaluationMode = false;
                    showFeedback('üéä Evaluasi selesai! Lanjutkan belajar huruf berikutnya!', 'success');
                }
            } else {
                currentFormIndex++;
                if (currentFormIndex >= 4) {
                    currentFormIndex = 0;
                    currentLetterIndex++;
                    
                    // Cek apakah perlu evaluasi (setiap 3 huruf)
                    if ((currentLetterIndex) % 3 === 0 && currentLetterIndex > 0) {
                        startEvaluation();
                        saveGameProgress(); // Simpan progress sebelum evaluasi
                        return;
                    }
                    
                    if (currentLetterIndex >= hijaiyahLetters.length) {
                        currentLetterIndex = 0;
                        showFeedback('üéâ Selamat! Anda telah menyelesaikan semua huruf! Game dimulai dari awal.', 'success');
                    }
                }
            }
            
            // Simpan progress setiap kali pindah huruf
            saveGameProgress();
            updateDisplay();
            clearCanvas();
        }

        function startEvaluation() {
            isEvaluationMode = true;
            currentEvaluationIndex = 0;
            
            // Pilih set kata berdasarkan progress
            const setIndex = Math.min(Math.floor(currentLetterIndex / 3) - 1, evaluationWordSets.length - 1);
            evaluationWords = evaluationWordSets[setIndex];
            
            showFeedback('üéØ Waktunya Evaluasi! Tulis kata-kata berikut dengan menyambungkan huruf-hurufnya!', 'success');
            updateDisplay();
        }

        function checkDrawing() {
            if (!hasDrawn) {
                showFeedback('‚úèÔ∏è Silakan tulis huruf terlebih dahulu!', 'encourage');
                return;
            }
            
            // Play success sound
            playSuccessSound();
            
            // Trigger celebration animation
            createCelebrationEffect();
            
            // Different scoring for evaluation mode
            if (isEvaluationMode) {
                score += 20; // Bonus untuk evaluasi
                const evaluationEncouragements = [
                    'üéä Excellent! Kata tersambung dengan baik!',
                    '‚≠ê Luar biasa! Sambungan huruf sempurna!',
                    'üåü Hebat! Penulisan kata yang indah!',
                    'üí™ Bravo! Semakin mahir menyambung huruf!',
                    'üéØ Perfect! Kata tertulis dengan rapi!',
                    'üèÜ Outstanding! Sambungan huruf terbaik!'
                ];
                
                const randomEncouragement = evaluationEncouragements[Math.floor(Math.random() * evaluationEncouragements.length)];
                showFeedback(randomEncouragement, 'success');
            } else {
                score += 10;
                const encouragements = [
                    'üëè Bagus sekali! Luar biasa!',
                    '‚≠ê Tulisan yang fantastis!',
                    'üåü Hebat! Sempurna!',
                    'üí™ Semakin mahir!',
                    'üéØ Tepat sasaran! Bravo!',
                    'üèÜ Luar biasa sekali!'
                ];
                
                const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
                showFeedback(randomEncouragement, 'success');
            }
            
            document.getElementById('score').textContent = score;
            
            // Simpan progress setiap kali skor bertambah
            saveGameProgress();
            
            // Auto advance after 3 seconds
            setTimeout(() => {
                nextLetter();
            }, 3000);
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type} show`;
        }

        function hideFeedback() {
            const feedback = document.getElementById('feedback');
            feedback.classList.remove('show');
        }

        // Audio functions using Web Audio API
        function playSuccessSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a cheerful success sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Play a happy melody
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                let noteIndex = 0;
                
                function playNote() {
                    if (noteIndex < notes.length) {
                        oscillator.frequency.setValueAtTime(notes[noteIndex], audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        
                        noteIndex++;
                        setTimeout(playNote, 150);
                    }
                }
                
                oscillator.type = 'sine';
                oscillator.start();
                playNote();
                
                setTimeout(() => {
                    oscillator.stop();
                }, 600);
                
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        // Celebration animation effect
        function createCelebrationEffect() {
            const container = document.querySelector('.game-container');
            
            // Create floating emojis
            const emojis = ['üéâ', '‚≠ê', 'üåü', 'üëè', 'üèÜ', 'üí´'];
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const emoji = document.createElement('div');
                    emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.cssText = `
                        position: fixed;
                        font-size: 2rem;
                        pointer-events: none;
                        z-index: 1000;
                        left: ${Math.random() * window.innerWidth}px;
                        top: ${window.innerHeight}px;
                        animation: floatUp 2s ease-out forwards;
                    `;
                    
                    document.body.appendChild(emoji);
                    
                    setTimeout(() => {
                        emoji.remove();
                    }, 2000);
                }, i * 100);
            }
            
            // Add pulse effect to score
            const scoreElement = document.querySelector('.score');
            scoreElement.style.animation = 'pulse 0.6s ease-in-out';
            setTimeout(() => {
                scoreElement.style.animation = '';
            }, 600);
        }

        // Initialize game
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawGuideLines();
        
        // Muat progress tersimpan saat game dimulai
        loadGameProgress();
        updateDisplay();

        // Prevent scrolling when touching the canvas
        document.body.addEventListener('touchstart', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchend', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchmove', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98a18fa346879daa',t:'MTc1OTcxNTk4NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
