<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Belajar Kaligrafi</title>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 800px;
            width: 100%;
        }

        .letter-display {
            background: white;
            color: #333;
            padding: 30px;
            border-radius: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            min-width: 200px;
        }

        .evaluation-mode {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            border: 3px solid #ff6b9d;
        }

        .word-display {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }

        .word-meaning {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 10px;
        }

        .evaluation-instruction {
            font-size: 1rem;
            color: #888;
            font-style: italic;
        }

        .current-letter {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
        }

        .letter-name {
            font-size: 1.5rem;
            color: #666;
            margin-bottom: 5px;
        }

        .letter-position {
            font-size: 1rem;
            color: #888;
            font-style: italic;
        }

        .canvas-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            margin: 20px 0;
        }

        #drawingCanvas {
            border: 3px dashed #ddd;
            border-radius: 15px;
            cursor: crosshair;
            touch-action: none;
            background-image: 
                linear-gradient(to right, #f0f0f0 1px, transparent 1px),
                linear-gradient(to bottom, #f0f0f0 1px, transparent 1px),
                linear-gradient(to bottom, #e0e0e0 1px, transparent 1px);
            background-size: 20px 20px, 20px 20px, 100% 50px;
            background-position: 0 0, 0 0, 0 25px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #a8e6cf, #7fcdcd);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feedback {
            padding: 15px 25px;
            border-radius: 15px;
            margin: 15px 0;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .feedback.show {
            opacity: 1;
        }

        .feedback.success {
            background: rgba(168, 230, 207, 0.9);
            color: #27ae60;
        }

        .feedback.encourage {
            background: rgba(255, 193, 7, 0.9);
            color: #f39c12;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #feca57; }
            100% { transform: scale(1); }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        .celebration-sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #ffd700, #ffed4e);
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .current-letter {
                font-size: 3rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">✨ Game Belajar Kaligrafi</div>
        <div class="subtitle">Belajar menulis huruf Arab dengan menyenangkan</div>
    </div>

    <div class="game-container">
        <div class="score">Skor: <span id="score">0</span></div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="letter-display">
            <div class="current-letter" id="currentLetter">ا</div>
            <div class="letter-name" id="letterName">Alif</div>
            <div class="letter-position" id="letterPosition">Bentuk Tunggal</div>
        </div>

        <div class="canvas-container">
            <canvas id="drawingCanvas" width="400" height="300"></canvas>
        </div>

        <div class="feedback" id="feedback"></div>

        <div class="controls">
            <button class="btn btn-primary" onclick="clearCanvas()">🗑️ Hapus</button>
            <button class="btn btn-secondary" onclick="nextLetter()">➡️ Huruf Berikutnya</button>
            <button class="btn btn-success" onclick="checkDrawing()">✅ Periksa Tulisan</button>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="resetGameProgress()" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">🔄 Reset Game</button>
        </div>
    </div>

    <script>
        // Data huruf Hijaiyah dengan berbagai bentuknya
        const hijaiyahLetters = [
            { letter: 'ا', name: 'Alif', forms: ['ا', 'ا', 'ـا', 'ـا'] },
            { letter: 'ب', name: 'Ba', forms: ['ب', 'بـ', 'ـبـ', 'ـب'] },
            { letter: 'ت', name: 'Ta', forms: ['ت', 'تـ', 'ـتـ', 'ـت'] },
            { letter: 'ث', name: 'Tsa', forms: ['ث', 'ثـ', 'ـثـ', 'ـث'] },
            { letter: 'ج', name: 'Jim', forms: ['ج', 'جـ', 'ـجـ', 'ـج'] },
            { letter: 'ح', name: 'Ha', forms: ['ح', 'حـ', 'ـحـ', 'ـح'] },
            { letter: 'خ', name: 'Kha', forms: ['خ', 'خـ', 'ـخـ', 'ـخ'] },
            { letter: 'د', name: 'Dal', forms: ['د', 'د', 'ـد', 'ـد'] },
            { letter: 'ذ', name: 'Dzal', forms: ['ذ', 'ذ', 'ـذ', 'ـذ'] },
            { letter: 'ر', name: 'Ra', forms: ['ر', 'ر', 'ـر', 'ـر'] },
            { letter: 'ز', name: 'Zai', forms: ['ز', 'ز', 'ـز', 'ـز'] },
            { letter: 'س', name: 'Sin', forms: ['س', 'سـ', 'ـسـ', 'ـس'] },
            { letter: 'ش', name: 'Syin', forms: ['ش', 'شـ', 'ـشـ', 'ـش'] },
            { letter: 'ص', name: 'Shad', forms: ['ص', 'صـ', 'ـصـ', 'ـص'] },
            { letter: 'ض', name: 'Dhad', forms: ['ض', 'ضـ', 'ـضـ', 'ـض'] },
            { letter: 'ط', name: 'Tha', forms: ['ط', 'طـ', 'ـطـ', 'ـط'] },
            { letter: 'ظ', name: 'Zha', forms: ['ظ', 'ظـ', 'ـظـ', 'ـظ'] },
            { letter: 'ع', name: 'Ain', forms: ['ع', 'عـ', 'ـعـ', 'ـع'] },
            { letter: 'غ', name: 'Ghain', forms: ['غ', 'غـ', 'ـغـ', 'ـغ'] },
            { letter: 'ف', name: 'Fa', forms: ['ف', 'فـ', 'ـفـ', 'ـف'] },
            { letter: 'ق', name: 'Qaf', forms: ['ق', 'قـ', 'ـقـ', 'ـق'] },
            { letter: 'ك', name: 'Kaf', forms: ['ك', 'كـ', 'ـكـ', 'ـك'] },
            { letter: 'ل', name: 'Lam', forms: ['ل', 'لـ', 'ـلـ', 'ـل'] },
            { letter: 'م', name: 'Mim', forms: ['م', 'مـ', 'ـمـ', 'ـم'] },
            { letter: 'ن', name: 'Nun', forms: ['ن', 'نـ', 'ـنـ', 'ـن'] },
            { letter: 'ه', name: 'Ha', forms: ['ه', 'هـ', 'ـهـ', 'ـه'] },
            { letter: 'و', name: 'Waw', forms: ['و', 'و', 'ـو', 'ـو'] },
            { letter: 'ي', name: 'Ya', forms: ['ي', 'يـ', 'ـيـ', 'ـي'] }
        ];

        const positions = ['Tunggal', 'Awal', 'Tengah', 'Akhir'];
        
        // Data kata untuk evaluasi sambung huruf
        const evaluationWordSets = [
            // Set 1: Kata sederhana dengan huruf awal
            [
                { word: 'بَا', meaning: 'Ba', letters: ['ب', 'ا'] },
                { word: 'تَا', meaning: 'Ta', letters: ['ت', 'ا'] },
                { word: 'ثَا', meaning: 'Tsa', letters: ['ث', 'ا'] }
            ],
            // Set 2: Kata dengan 3 huruf
            [
                { word: 'جَمَل', meaning: 'Unta', letters: ['ج', 'م', 'ل'] },
                { word: 'حَبَل', meaning: 'Tali', letters: ['ح', 'ب', 'ل'] },
                { word: 'خَبَر', meaning: 'Berita', letters: ['خ', 'ب', 'ر'] }
            ],
            // Set 3: Kata dengan huruf yang tidak sambung
            [
                { word: 'دَار', meaning: 'Rumah', letters: ['د', 'ا', 'ر'] },
                { word: 'ذَرَة', meaning: 'Atom', letters: ['ذ', 'ر', 'ة'] },
                { word: 'رَأس', meaning: 'Kepala', letters: ['ر', 'أ', 'س'] }
            ],
            // Set 4: Kata dengan huruf sambung
            [
                { word: 'سَمَك', meaning: 'Ikan', letters: ['س', 'م', 'ك'] },
                { word: 'شَمس', meaning: 'Matahari', letters: ['ش', 'م', 'س'] },
                { word: 'صَبَح', meaning: 'Pagi', letters: ['ص', 'ب', 'ح'] }
            ]
        ];
        
        let currentLetterIndex = 0;
        let currentFormIndex = 0;
        let score = 0;
        let hasDrawn = false;
        let isEvaluationMode = false;
        let evaluationWords = [];
        let currentEvaluationIndex = 0;

        // Local Storage functions
        function saveGameProgress() {
            const gameData = {
                currentLetterIndex: currentLetterIndex,
                currentFormIndex: currentFormIndex,
                score: score,
                isEvaluationMode: isEvaluationMode,
                currentEvaluationIndex: currentEvaluationIndex,
                lastSaved: new Date().toISOString()
            };
            
            localStorage.setItem('hijaiyahGameProgress', JSON.stringify(gameData));
            console.log('Progress tersimpan:', gameData);
        }

        function loadGameProgress() {
            try {
                const savedData = localStorage.getItem('hijaiyahGameProgress');
                if (savedData) {
                    const gameData = JSON.parse(savedData);
                    
                    currentLetterIndex = gameData.currentLetterIndex || 0;
                    currentFormIndex = gameData.currentFormIndex || 0;
                    score = gameData.score || 0;
                    isEvaluationMode = gameData.isEvaluationMode || false;
                    currentEvaluationIndex = gameData.currentEvaluationIndex || 0;
                    
                    // Update display dengan data yang dimuat
                    document.getElementById('score').textContent = score;
                    
                    // Jika dalam mode evaluasi, setup evaluasi
                    if (isEvaluationMode) {
                        const setIndex = Math.min(Math.floor(currentLetterIndex / 3) - 1, evaluationWordSets.length - 1);
                        evaluationWords = evaluationWordSets[setIndex];
                    }
                    
                    console.log('Progress dimuat:', gameData);
                    showFeedback('📱 Progress terakhir berhasil dimuat!', 'success');
                    setTimeout(() => hideFeedback(), 3000);
                }
            } catch (error) {
                console.log('Tidak ada progress tersimpan atau error:', error);
            }
        }

        function resetGameProgress() {
            localStorage.removeItem('hijaiyahGameProgress');
            currentLetterIndex = 0;
            currentFormIndex = 0;
            score = 0;
            isEvaluationMode = false;
            currentEvaluationIndex = 0;
            document.getElementById('score').textContent = score;
            updateDisplay();
            clearCanvas();
            showFeedback('🔄 Game direset ke awal!', 'success');
        }

        // Canvas setup
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let points = [];
        let smoothingFactor = 0.4;
        let minDistance = 2;
        let strokeHistory = [];
        let currentStroke = [];

        // Set canvas size responsively
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 40);
            canvas.width = maxWidth;
            canvas.height = Math.max(250, maxWidth * 0.75);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#333';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.globalCompositeOperation = 'source-over';
        }

        // Advanced smoothing functions
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function getAveragePoint(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }

        function smoothPath(points) {
            if (points.length < 3) return points;
            
            const smoothed = [];
            smoothed.push(points[0]);
            
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];
                
                // Apply weighted smoothing
                const smoothedPoint = {
                    x: prev.x * 0.25 + curr.x * 0.5 + next.x * 0.25,
                    y: prev.y * 0.25 + curr.y * 0.5 + next.y * 0.25
                };
                
                smoothed.push(smoothedPoint);
            }
            
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        // Drawing functions with balanced smoothing
        function startDrawing(e) {
            isDrawing = true;
            hasDrawn = true;
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            lastX = clientX - rect.left;
            lastY = clientY - rect.top;
            points = [{x: lastX, y: lastY, time: Date.now()}];
            currentStroke = [{x: lastX, y: lastY}];
        }

        function draw(e) {
            if (!isDrawing) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            const currentX = clientX - rect.left;
            const currentY = clientY - rect.top;
            const currentPoint = {x: currentX, y: currentY, time: Date.now()};
            
            // Only add point if it's far enough from the last point
            const lastPoint = points[points.length - 1];
            const distance = getDistance(lastPoint, currentPoint);
            
            if (distance < minDistance) return;
            
            points.push(currentPoint);
            currentStroke.push(currentPoint);
            
            // Draw connected smooth line in real-time
            if (points.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                
                if (points.length >= 3) {
                    // Use quadratic curve for smoothing but keep it connected
                    const prevPoint = points[points.length - 3];
                    const midPoint = points[points.length - 2];
                    const currPoint = points[points.length - 1];
                    
                    // Create smooth control point
                    const controlX = midPoint.x + (currPoint.x - prevPoint.x) * smoothingFactor * 0.5;
                    const controlY = midPoint.y + (currPoint.y - prevPoint.y) * smoothingFactor * 0.5;
                    
                    ctx.quadraticCurveTo(controlX, controlY, currentX, currentY);
                } else {
                    // Simple line for first segment
                    ctx.lineTo(currentX, currentY);
                }
                
                ctx.stroke();
            }
            
            // Keep reasonable number of points
            if (points.length > 5) {
                points.shift();
            }
            
            lastX = currentX;
            lastY = currentY;
        }

        function drawSmoothCurve(points) {
            if (points.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length - 2; i++) {
                const currentPoint = points[i];
                const nextPoint = points[i + 1];
                
                // Create control points for smooth Bezier curve
                const controlPoint = getAveragePoint(currentPoint, nextPoint);
                
                ctx.quadraticCurveTo(
                    currentPoint.x,
                    currentPoint.y,
                    controlPoint.x,
                    controlPoint.y
                );
            }
            
            // Draw the last segment
            if (points.length > 2) {
                const secondLast = points[points.length - 2];
                const last = points[points.length - 1];
                ctx.quadraticCurveTo(
                    secondLast.x,
                    secondLast.y,
                    last.x,
                    last.y
                );
            }
            
            ctx.stroke();
        }

        function stopDrawing() {
            if (isDrawing && currentStroke.length > 1) {
                // Save current stroke to history
                strokeHistory.push([...currentStroke]);
            }
            
            isDrawing = false;
            points = [];
            currentStroke = [];
        }

        function drawCompleteStroke(strokePoints) {
            if (strokePoints.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(strokePoints[0].x, strokePoints[0].y);
            
            if (strokePoints.length === 2) {
                ctx.lineTo(strokePoints[1].x, strokePoints[1].y);
            } else {
                for (let i = 1; i < strokePoints.length - 1; i++) {
                    const currentPoint = strokePoints[i];
                    const nextPoint = strokePoints[i + 1];
                    const controlPoint = getAveragePoint(currentPoint, nextPoint);
                    
                    ctx.quadraticCurveTo(
                        currentPoint.x,
                        currentPoint.y,
                        controlPoint.x,
                        controlPoint.y
                    );
                }
                
                // Final point
                const lastPoint = strokePoints[strokePoints.length - 1];
                ctx.lineTo(lastPoint.x, lastPoint.y);
            }
            
            ctx.stroke();
        }

        // Event listeners for both mouse and touch
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokeHistory = [];
            points = [];
            currentStroke = [];
            drawGuideLines();
            hasDrawn = false;
            hideFeedback();
        }

        function drawGuideLines() {
            ctx.save();
            ctx.strokeStyle = '#e8e8e8';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // Draw horizontal guide lines
            const centerY = canvas.height / 2;
            const quarterY = canvas.height / 4;
            const threeQuarterY = (canvas.height * 3) / 4;
            
            ctx.beginPath();
            ctx.moveTo(0, quarterY);
            ctx.lineTo(canvas.width, quarterY);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(0, threeQuarterY);
            ctx.lineTo(canvas.width, threeQuarterY);
            ctx.stroke();
            
            ctx.restore();
        }

        function updateDisplay() {
            const letterDisplay = document.querySelector('.letter-display');
            
            if (isEvaluationMode) {
                letterDisplay.classList.add('evaluation-mode');
                const currentWord = evaluationWords[currentEvaluationIndex];
                
                document.getElementById('currentLetter').textContent = currentWord.word;
                document.getElementById('letterName').textContent = currentWord.meaning;
                document.getElementById('letterPosition').textContent = 'Tulis kata ini dengan menyambungkan huruf-hurufnya';
            } else {
                letterDisplay.classList.remove('evaluation-mode');
                const currentLetter = hijaiyahLetters[currentLetterIndex];
                const currentForm = currentLetter.forms[currentFormIndex];
                
                document.getElementById('currentLetter').textContent = currentForm;
                document.getElementById('letterName').textContent = currentLetter.name;
                document.getElementById('letterPosition').textContent = `Bentuk ${positions[currentFormIndex]}`;
            }
            
            // Update progress
            const totalForms = hijaiyahLetters.length * 4;
            const currentProgress = (currentLetterIndex * 4 + currentFormIndex + 1);
            const progressPercent = (currentProgress / totalForms) * 100;
            document.getElementById('progressFill').style.width = progressPercent + '%';
        }

        function nextLetter() {
            if (isEvaluationMode) {
                currentEvaluationIndex++;
                if (currentEvaluationIndex >= evaluationWords.length) {
                    // Selesai evaluasi, kembali ke mode normal
                    isEvaluationMode = false;
                    showFeedback('🎊 Evaluasi selesai! Lanjutkan belajar huruf berikutnya!', 'success');
                }
            } else {
                currentFormIndex++;
                if (currentFormIndex >= 4) {
                    currentFormIndex = 0;
                    currentLetterIndex++;
                    
                    // Cek apakah perlu evaluasi (setiap 3 huruf)
                    if ((currentLetterIndex) % 3 === 0 && currentLetterIndex > 0) {
                        startEvaluation();
                        saveGameProgress(); // Simpan progress sebelum evaluasi
                        return;
                    }
                    
                    if (currentLetterIndex >= hijaiyahLetters.length) {
                        currentLetterIndex = 0;
                        showFeedback('🎉 Selamat! Anda telah menyelesaikan semua huruf! Game dimulai dari awal.', 'success');
                    }
                }
            }
            
            // Simpan progress setiap kali pindah huruf
            saveGameProgress();
            updateDisplay();
            clearCanvas();
        }

        function startEvaluation() {
            isEvaluationMode = true;
            currentEvaluationIndex = 0;
            
            // Pilih set kata berdasarkan progress
            const setIndex = Math.min(Math.floor(currentLetterIndex / 3) - 1, evaluationWordSets.length - 1);
            evaluationWords = evaluationWordSets[setIndex];
            
            showFeedback('🎯 Waktunya Evaluasi! Tulis kata-kata berikut dengan menyambungkan huruf-hurufnya!', 'success');
            updateDisplay();
        }

        function checkDrawing() {
            if (!hasDrawn) {
                showFeedback('✏️ Silakan tulis huruf terlebih dahulu!', 'encourage');
                return;
            }
            
            // Play success sound
            playSuccessSound();
            
            // Trigger celebration animation
            createCelebrationEffect();
            
            // Different scoring for evaluation mode
            if (isEvaluationMode) {
                score += 20; // Bonus untuk evaluasi
                const evaluationEncouragements = [
                    '🎊 Excellent! Kata tersambung dengan baik!',
                    '⭐ Luar biasa! Sambungan huruf sempurna!',
                    '🌟 Hebat! Penulisan kata yang indah!',
                    '💪 Bravo! Semakin mahir menyambung huruf!',
                    '🎯 Perfect! Kata tertulis dengan rapi!',
                    '🏆 Outstanding! Sambungan huruf terbaik!'
                ];
                
                const randomEncouragement = evaluationEncouragements[Math.floor(Math.random() * evaluationEncouragements.length)];
                showFeedback(randomEncouragement, 'success');
            } else {
                score += 10;
                const encouragements = [
                    '👏 Bagus sekali! Luar biasa!',
                    '⭐ Tulisan yang fantastis!',
                    '🌟 Hebat! Sempurna!',
                    '💪 Semakin mahir!',
                    '🎯 Tepat sasaran! Bravo!',
                    '🏆 Luar biasa sekali!'
                ];
                
                const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
                showFeedback(randomEncouragement, 'success');
            }
            
            document.getElementById('score').textContent = score;
            
            // Simpan progress setiap kali skor bertambah
            saveGameProgress();
            
            // Auto advance after 3 seconds
            setTimeout(() => {
                nextLetter();
            }, 3000);
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type} show`;
        }

        function hideFeedback() {
            const feedback = document.getElementById('feedback');
            feedback.classList.remove('show');
        }

        // Audio functions using Web Audio API
        function playSuccessSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a cheerful success sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Play a happy melody
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                let noteIndex = 0;
                
                function playNote() {
                    if (noteIndex < notes.length) {
                        oscillator.frequency.setValueAtTime(notes[noteIndex], audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        
                        noteIndex++;
                        setTimeout(playNote, 150);
                    }
                }
                
                oscillator.type = 'sine';
                oscillator.start();
                playNote();
                
                setTimeout(() => {
                    oscillator.stop();
                }, 600);
                
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        // Celebration animation effect
        function createCelebrationEffect() {
            const container = document.querySelector('.game-container');
            
            // Create floating emojis
            const emojis = ['🎉', '⭐', '🌟', '👏', '🏆', '💫'];
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const emoji = document.createElement('div');
                    emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.cssText = `
                        position: fixed;
                        font-size: 2rem;
                        pointer-events: none;
                        z-index: 1000;
                        left: ${Math.random() * window.innerWidth}px;
                        top: ${window.innerHeight}px;
                        animation: floatUp 2s ease-out forwards;
                    `;
                    
                    document.body.appendChild(emoji);
                    
                    setTimeout(() => {
                        emoji.remove();
                    }, 2000);
                }, i * 100);
            }
            
            // Add pulse effect to score
            const scoreElement = document.querySelector('.score');
            scoreElement.style.animation = 'pulse 0.6s ease-in-out';
            setTimeout(() => {
                scoreElement.style.animation = '';
            }, 600);
        }

        // Initialize game
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawGuideLines();
        
        // Muat progress tersimpan saat game dimulai
        loadGameProgress();
        updateDisplay();

        // Prevent scrolling when touching the canvas
        document.body.addEventListener('touchstart', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchend', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchmove', function(e) {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98a18fa346879daa',t:'MTc1OTcxNTk4NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
